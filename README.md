BreakOut 游戏制作说明
一、游戏定位：
2D小游戏

二、游戏玩法逻辑：
玩家控制挡板实现小球和游戏场景内的砖块相互碰撞，被碰到的砖块消失并生成不同的道具，道具可影响游戏进程，最后直到所有可被破坏的砖块全部消失即为胜利。

三、游戏实现设计：
面向对象设计，设计12个类涵盖游戏不同的功能。
1、游戏类作为底层框架，用于管理游戏，实现游戏状态的初始化、更新、重置、键盘的输入处理、场景渲染、碰撞实现、粒子特效等。
2、工具类：
将着色器处理和纹理处理单独封装，需要使用时调用即可。工具类又分为着色器类和纹理类。
（1）着色器类实现激活、编译、从外部传入着色器里的uniform变量、检查编译错误。激活使用OpenGL自带的glUseProgram函数，编译着色器则利用glCreateShader、glShaderSource、glCompileShader等自带函数将着色器创建出来，然后利用glCreateProgram、glAttachShader、glLinkProgram将上述创建的着色器链接成一个程序，最后再使用glDeleteShader删除之前创建出的着色器；设置uniform变量使用类似glUniform1f(glGetUniformLocation(this->ID, name), value)的自带函数；检查编译是否错误主要通过glGetShaderiv(object, GL_COMPILE_STATUS, &success）自带函数进行判断，如果经函数赋值后的success变量为0则不成功，同理着色器程序链接是否成功使用自带的glGetProgramiv(object, GL_LINK_STATUS, &success)进行判断。
（2）纹理类实现创建、绑定纹理功能。纹理类的构造函数初始化默认设置了纹理的宽、长、纹理格式、图像格式、纹理环绕过滤方式，这些变量本身都是unsigned int变量，使用OpenGL自带的GL_RGB/GL_REPEAT/GL_LINEAR赋值即可，另外在纹理构造函数中还使用glGenTextures函数生成纹理对象（该对象不含任何图像数据）；然后是创造具有图像数据的纹理函数的实现，该函数要传入纹理图像的宽高及纹理图片的路径，利用glBindTexture、glTexImage2D(GL_TEXTURE_2D, 0, this->Internal_Format, width, height, 0, this->Image_Format, GL_UNSIGNED_BYTE, data)、glTexParameteri等自带函数设置纹理；最后的绑定纹理函数封装了自带的函数 glBindTexture。
3、资源管理类：
主要实现文件的加载，即着色器和纹理图像数据的读写，该类的最大特点就是它是一个具有静态属性的单一实例类，即所有的变量和函数都用static进行修饰。该类使用了map数据结构将着色器或纹理对象与其名字进行一一对应；该类还实现了加载、获取和清理着色器或纹理的功能。
加载着色器的实现，传入参数为着色器语言代码的路径，首先创建一个ifstream文件流，并用传入的参数初始化该文件流，然后创建字符串流，利用<<读入符号和文件流的rdbuf()函数将数据读入到字符串流中，最后通过字符串流的str（）函数赋值给新创建的字符串变量，然后创建记录这些字符串变量的指针，将指针传入到着色器类自带的编译函数即可shader.Compile(vShaderCode, fShaderCode, gShaderFile != nullptr ? gShaderCode : nullptr)。
加载纹理主要通过stbi_load(file, &width, &height, &nrChannels, 0)自带函数接收图像数据，将图像数据用unsigned char*存储，然后使用纹理类的函数创建纹理。4、渲染类：
渲染场景。首先使用一个2D投影矩阵glm::ortho(0.0f, 800.0f, 600.0f, 0.0f, -1.0f, 1.0f)将屏幕的世界坐标转换为标准化设备坐标，这样所有的顶点坐标为屏幕上的像素坐标。然后创建一个顶点着色器和片段着色器用于四边形的着色。
渲染类封装了一个着色器对象，一个顶点数组对象及渲染和初始化函数。
（1）它的初始化函数主要配置VAO和VBO,主要流程就是利用glGenVertexArrays、glGenBuffers生成VAO和VBO对象，然后glBindBuffer、glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW)绑定缓冲并传入数据，最后glBindVertexArray绑定VAO，然后在通过glEnableVertexAttribArray(0)激活顶点数组并 glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)0)配置，让OpenGL知道数据如何处理，最后解绑。
（2）接下来是着色函数，传入参数为纹理对象、位置、尺寸、角度、颜色。首先激活着色器，然后通过glm::translate(model, glm::vec3(position, 0.0f))和glm::rotate(model, rotate, glm::vec3(0.0f, 0.0f, 1.0f))、glm::scale(model, glm::vec3(size, 1.0f))三个函数进行平移、旋转和缩放，注意这里的变换与代码顺序步骤是相反的，得到view矩阵，然后传入uniform变量，使用 glActiveTexture(GL_TEXTURE0)激活纹理，并调用纹理类绑定纹理，通过glBindVertexArray绑定VAO，使用glDrawArrays(GL_TRIANGLES, 0, 6)进行绘制，最后解绑。
（4）该类的使用位置及方式
这里在游戏类中创建一个渲染类指针全局变量，然后在游戏类的初始化函数中通过资源管理类先加载着色器并传入uniform变量给着色器，然后new一个渲染类对象并用刚刚的指针指向它，该对象已用上述着色器构造，最后使用资源管理类加载纹理。
最后在游戏类中的渲染函数里通过渲染类指针全局变量调用绘制函数进行绘制。
5、游戏物体类：
该类为游戏中的主要对象即砖块，该类具有位置、大小、速度、颜色、是否坚硬、是否被摧毁等属性，同时还有一个渲染类对象用于砖块的渲染。
同理该类也可被设置为玩家挡板，在初始化的时候生成一个玩家挡板，这里用创建指针表示，同理也是在游戏类的绘制函数中绘制挡板。玩家控制挡板使用游戏类封装的ProcessInput函数，利用位移==速度乘上时间的关系变化挡板位置，这里还要注意移动边界的判断。
6、游戏关卡类：
用于一个关卡的绘制，同时关卡包括了大量的砖块。这里使用vector存储游戏中的砖块，另有一个加载函数、一个绘制函数、一个初始化函数。
（1）加载函数：首先这里巧妙的使用了二维数组中的每个不同数字来定义不同的砖块，关卡根据读入的数字不同生成不同的砖块并按数组顺序排列和存储到vector中。这里的加载操作与资源管理类的加载操作一样，主要就是从外部文件中获取每个数字并存储，主要步骤先用ifstream读取路径数据，再利用while循环结构和getline（ifstream,line）将文件流中数据读到字符串中，用该字符串再初始化一个字符串流，再从字符串流中>>读取每个数字到一个临时变量，然后把每个变量存储到类的全局变量vector中，最后调用关卡类自己的初始化函数。
（2）初始化函数：通过已经存储好的二维数组，计算每个数字对应的砖块的宽、高、颜色和位置，将计算完的砖块压入到vector中存储。
（3）绘制函数：传入参数为渲染类对象，利用for循环渲染每个砖块，当然这里还要先判断每个砖块是否已被破坏。
（4）检查关卡是否完成，即检查场景中的每个砖块是否全部被销毁。
（5）关卡类的使用：在游戏类中以vector形式存储不同的关卡。每个关卡的二维数组里的数字都不一样，然后在游戏初始化函数中创建关卡类对象并调用加载函数，然后通过在游戏类的绘制函数中调用关卡类自身的绘制函数。
7、球类：
该类继承了游戏物体类，并具有额外的属性如半径、是否被固定，同时还有move函数（根据球的速度及边界移动球）。
该类使用方式，在游戏类中定义一个球类指针全局变量，在初始化函数中设置球的初始位置为玩家挡板的中心，然后在游戏类中的更新函数调用球的move函数不断的更新球的位置，在游戏类的渲染函数中调用球的渲染函数绘制。
8、游戏类中的碰撞：
游戏物体类之间的碰撞使用AABB方式检测，其原理是检测两个物体的边界是否重叠，即水平和竖直方向都发生重叠才证明是碰撞。碰撞之后再进行砖块处理，即如果砖块是坚硬的则不变，不坚硬则消失。将整个碰撞函数的实现加入到更新函数中，在每一帧都检查是否发生碰撞。
碰撞后的求处理，碰撞后球的位置要恢复不能和砖块重叠并向相反方向运动。
首先要判读球的碰撞方向，这里用向量点乘的最高值来判断方向，即用球的速度和东南西北四个垂直方向进行点乘。碰撞后根据球的碰撞方向反转球的速度分量即可。另外在更新函数中对球的位置要进行检测，如果球超出边界则重置关卡。
9、粒子生成器类：
用于球的尾迹粒子特效实现，首先这里要实现的效果就是在球的尾部持续不断的产生新的粒子并且旧的粒子会随着时间消失，同时它的颜色亮度同时又随着与发射器距离的增加而变暗。由上述可知，这里建立了一个结构体，表示一个粒子，每个粒子应具有速度、位置、颜色、生命时间等属性。另外粒子的渲染使用独立的着色器。首先粒子的顶点着色器包含粒子的位置、uv坐标，3个外部变量投影矩阵、偏移量、颜色，这里定义了一个浮点值用于把粒子缩小10倍，片段着色器则是采集纹理确定最终颜色，没什么特殊的地方。
粒子生成器类包含vector结构的粒子集合、粒子数量、着色器、纹理、存储顶点数据的VAO,初始化函数、寻找第一个生命结束的粒子函数、粒子消失后的更新函数、粒子生成器更新函数和绘制函数。
粒子生成器更新函数的逻辑：首先是增加新的粒子，每次都增加一定量的粒子，数量由传入参数决定，每次增加粒子前先找到生命时间为0的粒子，然后记录这个消失粒子的索引值，接下来用粒子更新函数替换该粒子即可，这样就能保持一个粒子生成器中的粒子总量是不变的。替换完后，遍历更新每个粒子的状态，即生命会随着时间减少，并且其位置和颜色值也会随着时间在变化，这里使用引用粒子数组中的粒子，方便记录每个粒子的状态。
粒子生成器的绘制函数：同样要激活着色器，这里使用了glBlendFunc(GL_SRC_ALPHA, GL_ONE)和glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)使得粒子叠加时会产生平滑的发热效果。这两句话中间就是粒子的渲染，包括着色器uniform变量的设置、纹理绑定、三角形图元绘制。注意在游戏类中绘制时，球本身的绘制是最后才调用。
粒子生成器的初始化函数：这里在构造器中进行初始化。主要是设置vbo和vao，并实例化粒子存入vector中。
最后是比较特殊的两个函数，一个是查找第一个生命为0的粒子，一般的思路就是遍历然后替换，但这里不一样，这里是定义了一个全局变量用来记录第一个消失的粒子，然后下次从这个粒子的索引值之后找生命为0的粒子，这样做的目的应该是保证整个粒子集的查找是有周期规律的。如果没找到的话就返回0，表示需要将第一个粒子替换。
粒子更新函数：表示将找到一个生命为0的粒子，将它的各项属性重置，这里使用rand函数随机定义其位置、颜色，但是生命值设置为1.0，速度设置为球的0.1.
10、后期处理类：
给游戏制造视觉效果，包括抖动效果、反转场景颜色。这几个效果的关键是纹理坐标的变换，比如反转场景颜色的在顶点着色器中的数学原理就是：TexCoords = vec2(1.0 - texture.x, 1.0 - texture.y)，震动的原理就是：gl_Position.x += cos(time * 10) * strength，gl_Position.y += cos(time * 15) * strength;，震动实际上就是短时间内微量移动顶点的位置，然后恢复。当然为创造显著的视觉效果，片段着色器也要有所不同。
片段着色器中在震动效果中用到了卷积矩阵，对纹理的偏移像素进行采样sample[i] = vec3(texture(scene, TexCoords.st + offsets[i]))，然后color += vec4(sample[i] * blur_kernel[i], 0.0f)，而反转则是color = vec4(1.0 - texture(scene, TexCoords).rgb, 1.0)，另外片段着色器中的uniform变量offsets是个数组，从外部也可传入，利用glUniform2fv(glGetUniformLocation(shader.ID, "offsets"), 9, (GLfloat*)offsets)传入。
这个类同样包含了自己的着色器、纹理、图像宽高、bool变量表是否震动、反转，还有场景渲染之前预处理后期帧缓冲的函数，以及在场景渲染完成后将所有的渲染数据存储到纹理上的函数，最后还有一个自己的绘制函数，将纹理渲染出来。这个类私人变量有两个帧缓冲，其中一个是多重采样帧缓冲，另一个是普通帧缓冲用于将前一个帧缓冲的内容拷贝到自己的纹理附件上。然后是渲染缓冲RBO和顶点数据VAO,最后还有一个初始化渲染数据的函数。
该类的构造器：上来也是默认初始化所有的变量，然后生成帧缓冲和渲染缓冲并绑定到自己的变量上。这里用到了glRenderbufferStorageMultisample(GL_RENDERBUFFER,8,GL_RGB,width,height)分配内存空间给到渲染缓冲；然后使用glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, this->RBO)将渲染缓冲绑定到类的第一个帧缓冲上。接下来绑定第二个普通帧缓冲，然后生成一个四边形纹理，然后使用glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this->Texture.ID, 0)将纹理绑定到普通帧缓冲上。注意这里的纹理还没有内容。接下来就是调用类自己的初始化渲染数据函数，这个函数主要是处理VBO和VAO。然后设置uniform的变量并传给着色器。
在endRender()函数中用到了这几行代码：
  glBindFramebuffer(GL_READ_FRAMEBUFFER, this->MSFBO);
  glBindFramebuffer(GL_DRAW_FRAMEBUFFER, this->FBO);
  glBlitFramebuffer(0, 0, this->Width, this->Height, 0, 0, this->Width, this->Height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
第一行表示，MSFBO只为可读取的帧缓冲，而第二行FBO为只写入的帧缓冲，而第三行表示将MSFBO的内容赋值到FBO中，使得FBO中的纹理附件有了内容。
后期处理类的绘制函数：激活着色器，设置一些uniform的变量，然后激活、绑定纹理，绑定VAO，绘制、解绑。
11、道具类：
让游戏可玩性增加，比如变换场景，增加小球的速度或者增加挡板长度等。该类继承自游戏物体类，但有自己的变量，比如string的道具类型，道具持续时间、道具是否被激活。道具有很多种，所以在游戏类中也是以vector数组形式存在，然后在游戏类中定义了两个管理道具的函数。
一个是在给定砖块位置生成一个道具的函数：表示每次砖块摧毁时希望以一定概率生成一个道具，其中里面的概率自己可单独封装成一个函数，返回值为bool变量，传入一个unsigned int的参数，原理就是利用rand()函数生成0-传入参数的随机数，return random == 0表示只有当随机数为0的时候才会返回TRUE，道具才会生成，随机数为0的概率就是跟传入的参数n相关，为1/n。然后主函数体内利用if语句（概率函数（n））来判断是否生成，如果生成，vector就压入一个道具类的实例（实例生成直接使用构造函数，传入道具的名称、颜色、持续时间、位置、纹理），这里注意功能是帮助玩家的道具的n一般大一些，而加速玩家死亡的坏道具n小一些。
激活道具：激活道具是在砖块被摧毁的同时生成道具，所以激活道具的借口函数跟道具摧毁代码是放在一起的，都放在碰撞处理的函数中。当然在碰撞处理函数的尾部需要遍历每个道具，如果道具没被摧毁，但是越过了游戏边界，这里就需要将道具类的摧毁属性变量改成true，然后检查是否和玩家挡板接触，如果接触则实现道具功能，这个功能也单独封装一个函数，同时把道具的摧毁属性和激活属性改为TRUE。
实现道具功能函数：根据不同的道具名称实现不同的功能，利用if语句即可，比如增加速度，在if函数体内将球的速度乘上一个变量实现。粘滞功能，将球的是否固定属性改为true，穿透功能，当砖块不可毁坏时小球直接穿过，但是这里没有直接将代码写出来，而是用来一个小球自身新增的bool变量穿透实现，具体的穿透功能代码处理放在了碰撞处理中，碰撞处理代码相较之前的代码其实就是新增了if语句判断中是否穿透的判断，只有不穿透和是坚固的砖块小球才会反弹。还有挡板尺寸增加，把玩家实例的尺寸的x值增大即可，另外两个负面的效果混乱和反转，将游戏类中的特效类指针所指向的实例中的属性改为true即可，那么在游戏渲染阶段自然会发生变换。
更新道具函数：目的就是保证道具生成后可以移动，并在每次更新都减少持续时间，当时间减为0时，道具失效并恢复相关状态。函数参数为时间dt，遍历vector中的道具，按照速度和给定参数时间dt改变位置,然后判断道具的持续时间，小于或等于0就设置道具本身的激活属性为false，并在根据不同的道具停用不同的效果，其实每种效果都做成了bool变量，只需将此效果对应的bool变量属性变为false即可，这就是为什么这里大量使用bool变量的原因，可以省去很多重复的代码。最后利用remove_if函数和lamda表达式消除这些对象this->PowerUps.erase(std::remove_if(this->PowerUps.begin(), this->PowerUps.end(), [](const PowerUp &powerUp) { return powerUp.Destroyed && !powerUp.Activated; } ), this->PowerUps.end()); }
remove_if函数将lamda表达式为true的元素移动至容器的末尾并返回一个迭代器指向应被移除的元素范围的开始部分。容器的erase函数接着擦除这个迭代器指向的元素与容器末尾元素之间的所有元素。
